"""Session journal writer for GeistFabrik.

Writes filtered suggestions to daily session notes in the geist journal directory.
Each session creates a note at <vault>/geist journal/YYYY-MM-DD.md with suggestions
formatted as Obsidian-compatible blocks with unique block IDs.
"""

import logging
import sqlite3
from datetime import datetime
from pathlib import Path
from typing import List

from .models import Suggestion

logger = logging.getLogger(__name__)


class JournalWriter:
    """Writes suggestions to session notes in the geist journal."""

    def __init__(self, vault_path: Path, db: sqlite3.Connection):
        """Initialise journal writer.

        Args:
            vault_path: Path to Obsidian vault root
            db: SQLite database connection
        """
        self.vault_path = vault_path
        self.db = db
        self.journal_dir = vault_path / "geist journal"

    def write_session(
        self, date: datetime, suggestions: List[Suggestion], mode: str = "default"
    ) -> Path:
        """Write session note with suggestions.

        Args:
            date: Session date
            suggestions: Suggestions to write
            mode: Invocation mode (for note metadata)

        Returns:
            Path to created session note

        Raises:
            FileExistsError: If session note already exists (prevents overwrites)
        """
        # Ensure journal directory exists
        self.journal_dir.mkdir(exist_ok=True)

        # Format date for filename and title
        date_str = date.strftime("%Y-%m-%d")
        session_path = self.journal_dir / f"{date_str}.md"

        # Check if session already exists
        if session_path.exists():
            raise FileExistsError(
                f"Session note already exists: {session_path}. Delete it first to regenerate."
            )

        # Generate content
        content = self._format_session_note(date, suggestions, mode)

        # Write to file
        session_path.write_text(content, encoding="utf-8")

        # Record in database
        self._record_suggestions(date_str, suggestions)

        return session_path

    def _format_session_note(self, date: datetime, suggestions: List[Suggestion], mode: str) -> str:
        """Format session note content.

        Args:
            date: Session date
            suggestions: Suggestions to format
            mode: Invocation mode

        Returns:
            Formatted markdown content
        """
        formatted_date = date.strftime("%B %-d, %Y")  # e.g., "January 15, 2025"

        lines = [
            f"# GeistFabrik Session â€“ {formatted_date}",
            "",
        ]

        # Add metadata
        if mode != "default":
            lines.append(f"_Mode: {mode}_")
            lines.append("")

        if not suggestions:
            lines.append("_No suggestions generated this session._")
        else:
            # Write each suggestion with block ID
            for i, suggestion in enumerate(suggestions, start=1):
                block_id = self._generate_block_id(date, i)
                lines.append(f"## {suggestion.geist_id} {block_id}")
                lines.append(suggestion.text)
                lines.append("")

        # Add footer
        lines.append("---")
        lines.append("")
        lines.append("_Generated by GeistFabrik_")

        return "\n".join(lines)

    def _generate_block_id(self, date: datetime, index: int) -> str:
        """Generate Obsidian block ID.

        Format: ^gYYYYMMDD-NNN

        Args:
            date: Session date
            index: Suggestion index (1-based)

        Returns:
            Block ID string
        """
        date_str = date.strftime("%Y%m%d")
        return f"^g{date_str}-{index:03d}"

    def _record_suggestions(self, date_str: str, suggestions: List[Suggestion]) -> None:
        """Record suggestions in database for novelty filtering.

        Args:
            date_str: Session date string (YYYY-MM-DD)
            suggestions: Suggestions to record
        """
        now = datetime.now().isoformat()

        for i, suggestion in enumerate(suggestions, start=1):
            block_id = self._generate_block_id(datetime.fromisoformat(date_str), i)

            self.db.execute(
                """
                INSERT INTO session_suggestions
                (session_date, geist_id, suggestion_text, block_id, created_at)
                VALUES (?, ?, ?, ?, ?)
                """,
                (date_str, suggestion.geist_id, suggestion.text, block_id, now),
            )

        try:
            self.db.commit()
        except sqlite3.Error as e:
            logger.error(f"Database commit failed recording suggestions: {e}")
            raise

    def session_exists(self, date: datetime) -> bool:
        """Check if session note already exists for date.

        Args:
            date: Date to check

        Returns:
            True if session note exists, False otherwise
        """
        date_str = date.strftime("%Y-%m-%d")
        session_path = self.journal_dir / f"{date_str}.md"
        return session_path.exists()

    def get_recent_suggestions(self, days: int = 60) -> List[str]:
        """Get suggestion texts from recent sessions.

        Args:
            days: Number of days to look back

        Returns:
            List of suggestion texts from recent sessions
        """
        from datetime import timedelta

        cutoff = (datetime.now() - timedelta(days=days)).strftime("%Y-%m-%d")

        cursor = self.db.execute(
            """
            SELECT suggestion_text
            FROM session_suggestions
            WHERE session_date >= ?
            ORDER BY session_date DESC
            """,
            (cutoff,),
        )

        return [row[0] for row in cursor.fetchall()]
